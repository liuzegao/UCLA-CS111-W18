NAME: Quentin Truong
EMAIL: quentintruong@gmail.com
ID: 404782322
---
- SortedList.h - a header file containing interfaces for linked list operations.
- SortedList.c - the source for a C source module that compiles cleanly (with no errors or warnings), and implements insert, delete, lookup, and length methods for a sorted doubly linked list (described in the provided header file, including correct placement of pthread_yield calls).
- lab2_list.c - the source for a C program that compiles cleanly (with no errors or warnings), and implements the specified command line options (--threads, --iterations, --yield, --sync, --lists), drives one or more parallel threads that do operations on a shared linked list, and reports on the final list and performance. 
- A Makefile to build the deliverable programs, output, graphs, and tarball. The higher level targets should be:
    - default ... the lab2_list executable (compiling with the -Wall and -Wextra options).
    - tests ... run all specified test cases to generate CSV results
    - profile ... run tests with profiling tools to generate an execution profiling report
    - graphs ... use gnuplot to generate the required graphs
    - dist ... create the deliverable tarball
    - clean ... delete all programs and output generated by the Makefile
- lab2b_list.csv - containing your results for all of test runs.
- profile.out - execution profiling report showing where time was spent in the un-partitioned spin-lock implementation.
- graphs (.png files), created by gnuplot(1) on the above csv data showing:
    - lab2b_1.png ... throughput vs. number of threads for mutex and spin-lock synchronized list operations.
    - lab2b_2.png ... mean time per mutex wait and mean time per operation for mutex-synchronized list operations.
    - lab2b_3.png ... successful iterations vs. threads for each synchronization method.
    - lab2b_4.png ... throughput vs. number of threads for mutex synchronized partitioned lists.
    - lab2b_5.png ... throughput vs. number of threads for spin-lock-synchronized partitioned lists.
    - any other files or scripts required to generate your results.
- a README file containing:
    - descriptions of each of the included files and any other information about your submission that you would like to bring to our attention (e.g. research, limitations, features, testing methodology).
    - brief (a few sentences per question) answers to each of the questions (below).
---
QUESTION 2.3.1 - Cycles in the basic list implementation:
A. Where do you believe most of the cycles are spent in the 1 and 2-thread list tests ?
B. Why do you believe these to be the most expensive parts of the code?
C. Where do you believe most of the time/cycles are being spent in the high-thread spin-lock tests?
D. Where do you believe most of the time/cycles are being spent in the high-thread mutex tests?
ANSWER 2.3.1
A.
B.
C.
D.
---
QUESTION 2.3.2 - Execution Profiling:
A. Where (what lines of code) are consuming most of the cycles when the spin-lock version of the list exerciser is run with a large number of threads?
B. Why does this operation become so expensive with large numbers of threads?
ANSWER 2.3.2
A.
B.
C.
---
QUESTION 2.3.3 - Mutex Wait Time:
Look at the average time per operation (vs. # threads) and the average wait-for-mutex time (vs. #threads).
A. Why does the average lock-wait time rise so dramatically with the number of contending threads?
B. Why does the completion time per operation rise (less dramatically) with the number of contending threads?
C. How is it possible for the wait time per operation to go up faster (or higher) than the completion time per operation?
ANSWER 2.3.3
A.
B.
C.
---
QUESTION 2.3.4 - Performance of Partitioned Lists
A. Explain the change in performance of the synchronized methods as a function of the number of lists.
B. Should the throughput continue increasing as the number of lists is further increased? If not, explain why not.
C. It seems reasonable to suggest the throughput of an N-way partitioned list should be equivalent to the throughput of a single list with fewer (1/N) threads. Does this appear to be true in the above curves? If not, explain why not.
ANSWER 2.3.4
A.
B.
C.
---






